// Copyright (c) 2018, 2023 IBM Corporation and others.
// Licensed under Creative Commons Attribution-NoDerivatives
// 4.0 International (CC BY-ND 4.0)
//   https://creativecommons.org/licenses/by-nd/4.0/
//
// Contributors:
//     IBM Corporation
//
:projectid: testcontainers
:page-layout: guide-multipane
:page-duration: 20 minutes
:page-releasedate: 2023-01-31
:page-guide-category: microprofile
:page-essential: false
:page-description: Learn how to test your microservices with multiple containers using Testcontainers and JUnit.
:page-seo-title: Testing Java microservices using Testcontainers and JUnit with multiple containers and OpenLiberty Docker container
:page-seo-description: A getting started tutorial on how to develop true-to-production integration tests for Java microservices in production-like settings by using Testcontainers and JUnit with multiple containers and Open Liberty Docker container.
:guide-author: Open Liberty
:page-tags: ['MicroProfile', 'Jakarta EE']
:page-related-guides: ['microshed-testing', 'reactive-service-testing', 'arquillian-managed']
:page-permalink: /guides/{projectid}
:repo-description: Visit the https://openliberty.io/guides/{projectid}.html[website] for the rendered version of the guide.
:common-includes: https://raw.githubusercontent.com/OpenLiberty/guides-common/prod
:source-highlighter: prettify
:imagesdir: /img/guide/{projectid}
= Building true-to-production integration tests with Testcontainers

[.hidden]
NOTE: This repository contains the guide documentation source. To view the guide in published form, view it on the https://openliberty.io/guides/{projectid}.html[Open Liberty website].

Learn how to test your microservices with multiple containers using Testcontainers and JUnit.

== What you'll learn

You'll learn how to write true-to-production integration tests for Java microservices by using https://www.testcontainers.org/[Testcontainers^] and JUnit. You'll learn to set up and configure multiple containers, including the Open Liberty Docker container, to simulate a production-like environment for your tests.

Sometimes tests might pass in development and testing (dev/test) environments, but fail in production because the application runs differently in production than in dev/test. Fortunately, you can minimize these differences between dev/test and production by testing your application in the same Docker containers that you'll use in production.

=== What is Testcontainers?

Testcontainers is an open source library that wraps Docker in a Java API. It's often used in testing applications that involve external resource dependencies such as databases, message queues, or web services. Testcontainers supports any Docker image, which allows for uniform and portable testing environments. By encapsulating dependencies in containers, it ensures test consistency and simplifies the setup process.

The microservice that you'll be working with is called `inventory`. The `inventory` microservice persists data into a PostgreSQL database and supports create, retrieve, update, and delete (CRUD) operations on the database records. You will write integration tests for the application by using Testcontainers to run it in Docker containers.

image::inventory.png[Inventory microservice,align="center"]

// =================================================================================================
// Additional prerequisites
// =================================================================================================
== Additional prerequisites

Before you begin, Docker needs to be installed. For installation instructions, refer to the https://docs.docker.com/get-docker/[official Docker documentation^]. You'll test the application in Docker containers.

Make sure to start your Docker daemon before you proceed.

// =================================================================================================
// Getting Started
// =================================================================================================
[role='command']
include::{common-includes}/gitclone.adoc[]

// =================================================================================================
// Try what you'll build
// =================================================================================================
=== Try what you'll build

This guide use Docker to run an instance of the PostgreSQL database for a fast installation and setup. A Dockerfile file is provided for you. Navigate to the `postgres` directory and run the following commands to use the Dockerfile to build the image:

[role='command']
```
cd postgres
docker build -t postgres-sample .
```

The `finish` directory in the root of this guide contains the finished application. Give it a try before you proceed.

To try out the test, first go to the `finish` directory and run the `mvn package` command so that the `.war` file resides in the `target` directory:

[role='command']
```
cd ../finish
mvn package
```

Run the following command to download or update to the latest Open Liberty Docker image:

[role='command']
```
docker pull icr.io/appcafe/open-liberty:full-java11-openj9-ubi
```

Build your Docker image with the following command:

[role='command']
```
docker build -t inventory:1.0-SNAPSHOT .
```

Now, run the Maven `verify` goal which compiles the java files, starts the containers, runs the tests, and then stops the containers.

[role='command']
```
mvn verify
```

You will see the following output:

[role="no_copy"]
----
 -------------------------------------------------------
  T E S T S
 -------------------------------------------------------
 Running it.io.openliberty.guides.inventory.SystemResourceIT
 ...
 Tests run: 3, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 10.118 s - in it.io.openliberty.guides.inventory.SystemResourceIT

 Results:

 Tests run: 3, Failures: 0, Errors: 0, Skipped: 0
----

// =================================================================================================
// Implementing integration tests
// =================================================================================================
== Implementing integration tests

Navigate to the `start` directory to begin.

Run the following command to start the PostgreSQL database, which runs the `postgres-sample` image in a Docker container and maps `5432` port from the container to your host machine:

[role='command']
```
docker run --name postgres-container -p 5432:5432 -d postgres-sample
```

include::{common-includes}/devmode-lmp33-start.adoc[]

=== Building the test REST client

Test REST client is responsible for sending HTTP requests to an application and handling the responses. It enables accurate verification of the application's behavior by ensuring it responds correctly to various scenarios and conditions.

Begin by creating a test REST client interface for the `inventory` microservice.

[role="code_command hotspot file=0" ,subs="quotes"]
----
#Create the `SystemResourceClient.java` file.#
`src/test/java/it/io/openliberty/guides/inventory/SystemResourceClient.java`
----

// file 0
SystemResourceClient.java
[source, java, linenums, role="code_column hide_tags=copyright"]
----
include::finish/src/test/java/it/io/openliberty/guides/inventory/SystemResourceClient.java[]
----

The [hotspot file=0]`SystemResourceClient` interface declares the [hotspot=listContents file=0]`listContents()`, [hotspot=getSystem file=0]`getSystem()`, [hotspot=addSystem file=0]`addSystem()`, [hotspot=updateSystem file=0]`updateSystem()`, and [hotspot=removeSystem file=0]`removeSystem()` methods for accessing the corresponding endpoints within the `inventory` microservice.

Next, create the `SystemData` data model for testing.

[role="code_command hotspot file=1" ,subs="quotes"]
----
#Create the `SystemData.java` file.#
`src/test/java/it/io/openliberty/guides/inventory/SystemData.java`
----

// file 1
SystemData.java
[source, java, linenums, role="code_column hide_tags=copyright"]
----
include::finish/src/test/java/it/io/openliberty/guides/inventory/SystemData.java[]
----

The [hotspot file=1]`SystemData` class contains the ID, hostname, operating system name, Java version, and heap size properties. The various [hotspot=getMethods file=1]`get` and [hotspot=setMethods file=1]`set` methods within this class enable you to view and edit the properties of each system in the inventory.

=== Building test cases

Now you can start writing the tests that use the `SystemResourceClient` test REST client.

[role="code_command hotspot file=0" ,subs="quotes"]
----
#Create the `SystemResourceIT.java` file.#
`src/test/java/it/io/openliberty/guides/inventory/SystemResourceIT.java`
----

// file 0
SystemResourceIT.java
[source, java, linenums, role="code_column hide_tags=copyright"]
----
include::staging/src/test/java/it/io/openliberty/guides/inventory/SystemResourceIT.java[]
----

The [hotspot=createRestClient file=0]`createRestClient()` method creates a REST client instance with the `SystemResourceClient` interface, and configures a hostname verifier if the tests run over HTTPS.

The [hotspot=setup file=0]`setup` method determines the protocol to use (HTTP or HTTPS), checks if the Postgres database is running, and builds the base URL path for the client. If the Postgres database isn't running, it throws an exception, preventing further testing.

The [hotspot=testAddSystem file=0]`testAddSystem()` verifies the [hotspot=addSystem file=0]`addSystem` and [hotspot=listContents file=0]`listContents` endpoints.

The [hotspot=testUpdateSystem file=0]`testUpdateSystem()` verifies the [hotspot=updateSystem file=0]`updateSystem` and [hotspot=getSystem file=0]`getSystem` endpoints.

The [hotspot=testRemoveSystem file=0]`testRemoveSystem()` verifies the [hotspot=removeSystem file=0]`removeSystem` endpoint.

Because you started Open Liberty in dev mode, you can run the tests by pressing the `enter/return` key from the command-line session where you started dev mode. You see that the test passed.

// =================================================================================================
// Enhancing integration tests to use Testcontainers
// =================================================================================================
== Enhancing integration tests to use Testcontainers

Next, you will learn how to use Testcontainers to verify your microservices in the same Docker containers that you'll use in production.

=== Building Testcontainer for Open Liberty

Start by defining a custom `LibertyContainer` class which provides a framework to start and access a containerized version of the Open Liberty application for testing.

[role="code_command hotspot file=0" ,subs="quotes"]
----
#Create the `LibertyContainer.java` file.#
`src/test/java/it/io/openliberty/guides/inventory/LibertyContainer.java`
----

// file 0
LibertyContainer.java
[source, java, linenums, role="code_column hide_tags=copyright"]
----
include::finish/src/test/java/it/io/openliberty/guides/inventory/LibertyContainer.java[]
----

The [hotspot file=0]`LibertyContainer` class extends the [hotspot=GenericContainer file=0]`GenericContainer` class from Testcontainers to create a custom container configuration specific to the Open Liberty application.

The [hotspot=addExposedPorts1 hotspot=addExposedPorts2 file=0]`addExposedPorts(port)` method exposes specified ports from the container's perspective, allowing test clients to communicate with services running inside the container. To avoid any port conflicts, Testcontainers assigns random host ports to these exposed container ports. 

The [hotspot=waitingFor file=0]`Wait.forLogMessage()` method directs `LibertyContainer` to wait for the specific `CWWKF0011I` log message that indicates the Liberty server has started successfully.

Now you can set up trace logging for your tests. 

Having reliable logs is essential for efficient debugging, as they provide detailed insights into the test execution flow and help pinpoint issues during test failures. Testcontainers' built-in `Slf4jLogConsumer` enables integration of container output directly with the JUnit process, enhancing log analysis and simplifying test creation and debugging.

Create the log4j properties to configure the logging behavior in your tests.

[role="code_command hotspot file=1" ,subs="quotes"]
----
#Create the `log4j.properties` file.#
`src/test/resources/log4j.properties`
----

// file 1
log4j.properties
[source, properties, linenums, role='code_column']
----
include::finish/src/test/resources/log4j.properties[]
----

The [hotspot file=1]`log4j.properties` file configures the root logger, appenders, and layouts for console output. It sets the logging level to `DEBUG` for the [hotspot=package file=1]`it.io.openliberty.guides.inventory` package. This level provides detailed logging information for the specified package, which can be helpful for debugging and understanding test behavior. For more information about log4j properties and configuration, see the https://logging.apache.org/log4j/1.2/manual.html[Log4j 1.2 official documentation^].

=== Starting Testcontainers

The next step is to integrate Testcontainers into your tests.

[role="code_command hotspot file=0" ,subs="quotes"]
----
#Replace the `SystemResourceIT.java` file.#
`src/test/java/it/io/openliberty/guides/inventory/SystemResourceIT.java`
----

// file 0
SystemResourceIT.java
[source, java, linenums, role="code_column hide_tags=copyright"]
----
include::finish/src/test/java/it/io/openliberty/guides/inventory/SystemResourceIT.java[]
----

Define the [hotspot=postgresContainer file=0]`postgresContainer` test container to start up the PostgreSQL docker image, and define the [hotspot=inventoryContainer file=0]`inventoryContainer` test container to start up the `inventory` docker image. Since containers are isolated by default, make sure both containers use the same [hotspot=network1 hotspot=network2 hotspot=network3 file=0]`network` for them to communicate.

The [hotspot=waitingFor file=0]`Wait.forHttp().forPort()` method ensures the `inventoryContainer` is ready before tests run by checking the HTTP 200 status code at the specified endpoint and port. For different container readiness check customizations, refer to the https://www.testcontainers.org/features/startup_and_waits/[official Testcontainers documentation^].

The [hotspot=getLogger file=0]`LoggerFactory.getLogger()` and [hotspot=withLogConsumer1 hotspot=withLogConsumer2 file=0]`withLogConsumer(new Slf4jLogConsumer(Logger))` methods integrate container logs with the test logs by piping the container output to the specified logger.

=== Configuring Maven project

Next, configure your test build with Maven. 

[role="code_command hotspot file=0" ,subs="quotes"]
----
#Replace the `pom.xml` file.#
`pom.xml`
----

// file 0
pom.xml
[source, XML, linenums, role='code_column']
----
include::finish/pom.xml[]
----

Add the required `dependency` for Testcontainers and Log4J libraries with `test` scope. The [hotspot=testcontainers file=0]`testcontainers` dependency offers a general-purpose API for managing container-based test environments. The [hotspot=slf4j file=0]`slf4j-reload4j` dependency enables the Simple Logging Facade for Java (SLF4J) API for trace logging during test execution and facilitates debugging and test performance tracking. 

Also, add the [hotspot=failsafe file=0]`maven-failsafe-plugin` plugin, so that the integration test can be run by the Maven `verify` goal.

Save the changes, and press the `enter/return` key in your console window to run the tests. You see that the test passed. Notice that the `it.io.openliberty.guides.inventory.SystemResourceIT - Testing by dev mode or local runtime...` log indicates that the test continues to run in dev mode or local runtime.

// =================================================================================================
// Testing outside of development mode
// =================================================================================================
== Testing outside of development mode

Running tests in development mode is useful for local development, but there may be times when you want to test your application in other scenarios, such as in a CI/CD pipeline. For these cases, you can use Testcontainers to run tests against a running Open Liberty server in a controlled, self-contained environment, ensuring your tests run consistently regardless of the deployment context.

To test outside of development mode, exit dev mode by pressing `CTRL+C` in the command-line session where you ran the server, or by typing `q` and then pressing the `enter/return` key.

Also, run the following commands to stop the PostgreSQL container that was started in the previous section:

[role='command']
```
docker stop postgres-container
docker rm postgres-container
```

Rebuild the application using `mvn package`.

[role='command']
```
mvn package
```

Run the docker build command to rebuild container image for your application:

[role='command']
```
docker build -t inventory:1.0-SNAPSHOT .
```

Now, use the following Maven goal to run the tests from a cold start outside of development mode:

[role='command']
```
mvn verify
```

You will see the following output:

[role="no_copy"]
----
 -------------------------------------------------------
  T E S T S
 -------------------------------------------------------
 Running it.io.openliberty.guides.inventory.SystemResourceIT
 it.io.openliberty.guides.inventory.SystemResourceIT  - Testing by using Testcontainers...
 ...
 Tests run: 3, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 12.208 s - in it.io.openliberty.guides.inventory.SystemResourceIT

 Results:

 Tests run: 3, Failures: 0, Errors: 0, Skipped: 0
----

Notice that the test initiates a new Docker container each for the PostgreSQL database and the `inventory` microservice, resulting in a longer test runtime. Despite this, cold start testing benefits from a clean instance per run and ensures consistent results. These tests also automatically hook into existing build pipelines that are set up to run the `integration-test` phase.

// =================================================================================================
// Great work! You're done!
// =================================================================================================
== Great work! You're done!

You just tested your microservices with multiple Docker containers using Testcontainers.

include::{common-includes}/attribution.adoc[subs="attributes"]
